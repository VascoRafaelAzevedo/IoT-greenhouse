name: CI

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main, develop ]

jobs:
  build-test:
    runs-on: ubuntu-latest
    env:
      CI: true
      BACKEND_PORT: 4000
      VITE_API_URL: http://localhost:4000
      USE_MOCK_DB: false
      # Use test database for backend and consumer (postgres creates both DBs)
      DATABASE_URL: postgresql://postgres:change_me_strong_pass@postgres:5432/greenhouse_test
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Copy env example
        run: cp .env.example .env

      - name: Build images
        run: docker compose build backend consumer frontend

      - name: Start core stack (DB + MQTT + Backend + Consumer) in TEST mode
        run: |
          echo "Starting services with test database (greenhouse_test)..."
          docker compose up -d postgres mosquitto backend consumer
          echo "Services started"

      - name: Wait for Postgres healthy
        run: |
          for i in {1..25}; do
            STATUS=$(docker inspect -f '{{json .State.Health.Status}}' gardenaway-postgres || echo '"starting"');
            echo "Postgres health: $STATUS";
            if [ "$STATUS" = '"healthy"' ]; then exit 0; fi; sleep 3;
          done; echo "Postgres not healthy in time"; docker logs gardenaway-postgres; exit 1

      - name: Verify required extensions
        run: |
          docker exec gardenaway-postgres psql -U ${DB_USER:-postgres} -d ${DB_NAME_TEST:-greenhouse_test} -tAc "SELECT extname FROM pg_extension WHERE extname='timescaledb'" | grep timescaledb || (echo 'timescaledb extension missing' && exit 1)

      - name: List tables (debug)
        run: docker exec gardenaway-postgres psql -U ${DB_USER:-postgres} -d ${DB_NAME_TEST:-greenhouse_test} -c "\\dt"

      - name: Assert core tables exist
        run: |
          set -e
          REQUIRED="timezone app_user greenhouse setpoint connection_event telemetry plants"
          echo "Verifying core tables..."
          for t in $REQUIRED; do
            echo "Checking table: $t"
            docker exec gardenaway-postgres psql -U ${DB_USER:-postgres} -d ${DB_NAME_TEST:-greenhouse_test} -v ON_ERROR_STOP=1 -tAc \
              "SELECT relname FROM pg_catalog.pg_class c JOIN pg_namespace n ON n.oid=c.relnamespace \
               WHERE n.nspname='public' AND c.relkind='r' AND relname='${t}'" | grep -qx "${t}" || {
                 echo "Missing table ${t}. Debug info:"
                 docker exec gardenaway-postgres psql -U ${DB_USER:-postgres} -d ${DB_NAME_TEST:-greenhouse_test} -c "\dt public.${t}"
                 docker exec gardenaway-postgres psql -U ${DB_USER:-postgres} -d ${DB_NAME_TEST:-greenhouse_test} -c \
                   "SELECT oid, relkind, relname FROM pg_class WHERE relname='${t}'"
                 exit 1
               }
          done
          echo "All core tables present."

      - name: Strict seed validation
        run: |
          set -e
          echo "Validating seeded row counts in greenhouse_test database..."
          declare -A expected
          expected[timezone]=26
          expected[app_user]=2
          expected[greenhouse]=4
          expected[plants]=15
          expected[setpoint]=4
          expected[connection_event]=10
          expected[telemetry]=10
          for table in "${!expected[@]}"; do
            count=$(docker exec gardenaway-postgres psql -U ${DB_USER:-postgres} -d ${DB_NAME_TEST:-greenhouse_test} -tAc "SELECT count(*) FROM $table" | tr -d '[:space:]')
            echo "$table => $count (expected ${expected[$table]})"
            if [ "$count" != "${expected[$table]}" ]; then
              echo "FAIL: Table $table expected ${expected[$table]} rows, found $count"
              exit 1
            fi
          done

          echo "Checking specific seed values (emails)..."
          docker exec gardenaway-postgres psql -U ${DB_USER:-postgres} -d ${DB_NAME_TEST:-greenhouse_test} -tAc \
            "SELECT 1 FROM app_user WHERE email='vasco@example.com'" | grep -q 1 || { echo 'Missing vasco@example.com'; exit 1; }
          docker exec gardenaway-postgres psql -U ${DB_USER:-postgres} -d ${DB_NAME_TEST:-greenhouse_test} -tAc \
            "SELECT 1 FROM app_user WHERE email='maria@example.com'" | grep -q 1 || { echo 'Missing maria@example.com'; exit 1; }
          

          echo "Verifying telemetry hypertable..."
          docker exec gardenaway-postgres psql -U ${DB_USER:-postgres} -d ${DB_NAME_TEST:-greenhouse_test} -tAc \
            "SELECT hypertable_name FROM timescaledb_information.hypertables WHERE hypertable_schema='public' AND hypertable_name='telemetry'" | grep -q telemetry \
            || { echo 'telemetry is not a hypertable'; exit 1; }

          echo "Checking insert blocker trigger presence (optional)..."
          docker exec gardenaway-postgres psql -U ${DB_USER:-postgres} -d ${DB_NAME_TEST:-greenhouse_test} -tAc \
            "SELECT 1 FROM pg_trigger WHERE tgname='ts_insert_blocker'" | grep -q 1 \
            || { echo 'Trigger ts_insert_blocker missing'; exit 1; }

          echo "Seed validation PASSED."

      - name: Backend API health endpoint
        run: |
          echo "Testing backend API on port 4000..."
          for i in {1..15}; do 
            curl -fsS http://localhost:4000/ | grep -q "GardenAway API" && { echo "Backend API is healthy"; exit 0; } || sleep 2
          done
          echo 'Backend API health check failed'
          docker logs gardenaway-backend
          exit 1

      - name: Frontend build and health check
        run: |
          echo "Verifying frontend container is running..."
          docker ps | grep gardenaway-frontend || { echo "Frontend container not running"; docker logs gardenaway-frontend; exit 1; }
          echo "Testing frontend HTTP response..."
          for i in {1..10}; do curl -fsS http://localhost:3000/ && exit 0 || sleep 2; done; echo 'Frontend health check failed'; docker logs gardenaway-frontend; exit 1

      - name: MQTT broker smoke test (publish/subscribe)
        run: |
          docker exec gardenaway-mosquitto sh -c "(mosquitto_sub -t ci/test -C 1 > /tmp/ci_msg.out &) ; sleep 1; mosquitto_pub -t ci/test -m ci-ok; sleep 2; cat /tmp/ci_msg.out" | grep ci-ok || (echo 'MQTT smoke test failed' && exit 1)

      # ========== CONSUMER TESTS ==========
      
      - name: Install Rust toolchain
        uses: actions-rust-lang/setup-rust-toolchain@v1
        with:
          toolchain: stable
          components: rustfmt, clippy

      - name: Rust formatting check
        working-directory: consumer
        run: cargo fmt --check

      - name: Rust linting (clippy)
        working-directory: consumer
        run: cargo clippy -- -D warnings

      - name: Consumer unit tests
        working-directory: consumer
        run: |
          echo "Running 30 unit tests for models validation..."
          cargo test --lib --verbose
          echo "All unit tests passed"

      - name: Verify consumer is running
        run: |
          docker ps | grep gardenaway-consumer || { echo "Consumer container not running"; docker logs gardenaway-consumer; exit 1; }
          echo "Consumer container is running"

      - name: Wait for consumer to be ready
        run: |
          echo "Waiting for consumer to establish MQTT connection..."
          for i in {1..20}; do
            docker logs gardenaway-consumer 2>&1 | grep -q "MQTT connected" && { echo "Consumer connected to MQTT"; break; } || sleep 2
            if [ $i -eq 20 ]; then
              echo "Consumer did not connect to MQTT in time"
              docker logs gardenaway-consumer
              exit 1
            fi
          done

      - name: Snapshot database state (before integration tests)
        run: |
          echo "Taking snapshot of database state before integration tests..."
          docker exec gardenaway-postgres psql -U postgres -d greenhouse_test -tAc "SELECT count(*) FROM telemetry" > /tmp/telemetry_count_before.txt
          docker exec gardenaway-postgres psql -U postgres -d greenhouse_test -tAc "SELECT count(*) FROM connection_event" > /tmp/connection_event_count_before.txt
          BEFORE_TELEMETRY=$(cat /tmp/telemetry_count_before.txt | tr -d '[:space:]')
          BEFORE_CONNECTIONS=$(cat /tmp/connection_event_count_before.txt | tr -d '[:space:]')
          echo "Before - Telemetry rows: $BEFORE_TELEMETRY"
          echo "Before - Connection events: $BEFORE_CONNECTIONS"
          echo "BEFORE_TELEMETRY=$BEFORE_TELEMETRY" >> $GITHUB_ENV
          echo "BEFORE_CONNECTIONS=$BEFORE_CONNECTIONS" >> $GITHUB_ENV

      - name: Consumer integration tests (edge cases)
        run: |
          echo "Running extensive integration tests with CI-optimized script..."
          
          # Make scripts executable
          chmod +x consumer/test_consumer_ci.sh
          chmod +x consumer/test_consumer_edge_cases.sh
          
          # Install mosquitto clients if not available
          sudo apt-get update -qq
          sudo apt-get install -y mosquitto-clients jq
          
          # Run CI-optimized tests (includes MQTT functionality verification)
          cd consumer
          ./test_consumer_ci.sh
          
          echo "Integration tests completed"

      - name: Verify database changes after integration tests
        run: |
          echo "Verifying database state changes..."
          
          # Give consumer time to process all messages
          sleep 5
          
          AFTER_TELEMETRY=$(docker exec gardenaway-postgres psql -U postgres -d greenhouse_test -tAc "SELECT count(*) FROM telemetry" | tr -d '[:space:]')
          AFTER_CONNECTIONS=$(docker exec gardenaway-postgres psql -U postgres -d greenhouse_test -tAc "SELECT count(*) FROM connection_event" | tr -d '[:space:]')
          
          echo "After - Telemetry rows: $AFTER_TELEMETRY"
          echo "After - Connection events: $AFTER_CONNECTIONS"
          
          # Calculate differences
          TELEMETRY_DIFF=$((AFTER_TELEMETRY - BEFORE_TELEMETRY))
          CONNECTIONS_DIFF=$((AFTER_CONNECTIONS - BEFORE_CONNECTIONS))
          
          echo "Changes:"
          echo "  - Telemetry rows added: $TELEMETRY_DIFF"
          echo "  - Connection events added: $CONNECTIONS_DIFF"
          
          # Validate that valid messages were inserted
          # From the integration test script, we expect ~15-20 valid messages out of 35+ tests
          if [ $TELEMETRY_DIFF -lt 10 ]; then
            echo "Warning: Expected at least 10 new telemetry rows, got $TELEMETRY_DIFF"
            echo "This might indicate consumer is rejecting valid messages"
          fi
          
          if [ $TELEMETRY_DIFF -gt 30 ]; then
            echo "Error: Too many telemetry rows added ($TELEMETRY_DIFF)"
            echo "Consumer may be accepting invalid messages that should be rejected"
            exit 1
          fi
          
          echo "Database changes are within expected range"

      - name: Verify consumer processed duplicate messages correctly
        run: |
          echo "Checking duplicate message handling..."
          
          # The integration tests publish duplicate messages (same timestamp + sequence)
          # Check consumer logs for deduplication messages
          docker logs gardenaway-consumer 2>&1 | grep "Duplicate telemetry ignored" && {
            echo "Consumer correctly detected and ignored duplicate messages"
          } || {
            echo "No duplicate messages detected (this is OK if duplicates weren't sent yet)"
          }

      - name: Test consumer MQTT resilience
        run: |
          echo "Testing MQTT connection resilience..."
          
          # Restart MQTT broker
          docker restart gardenaway-mosquitto
          
          # Wait for broker to be ready
          sleep 3
          
          # Check if consumer reconnects
          for i in {1..15}; do
            docker logs gardenaway-consumer --since 10s 2>&1 | grep -q "MQTT connected\|Reconnecting" && {
              echo "Consumer successfully reconnected to MQTT broker"
              break
            }
            sleep 2
            if [ $i -eq 15 ]; then
              echo "Consumer failed to reconnect to MQTT"
              docker logs gardenaway-consumer --tail 50
              exit 1
            fi
          done

     

      - name: Show running containers
        run: docker compose ps

      - name: Consumer logs summary
        run: |
          echo "Consumer logs summary:"
          echo "========================="
          docker logs gardenaway-consumer 2>&1 | tail -100

      - name: Logs on failure
        if: failure()
        run: |
          echo "=== Backend API Logs ==="
          docker logs gardenaway-backend --tail 200
          echo "=== Frontend Logs ==="
          docker logs gardenaway-frontend --tail 100
          echo "=== Consumer Logs ==="
          docker logs gardenaway-consumer --tail 200
          echo "=== Postgres Logs ==="
          docker logs gardenaway-postgres --tail 100
          echo "=== MQTT Logs ==="
          docker logs gardenaway-mosquitto --tail 100

      - name: Tear down
        if: always()
        run: docker compose down -v
